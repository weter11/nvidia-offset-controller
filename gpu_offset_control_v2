#!/usr/bin/env python3
"""
GPU Offset Control Script using NVML
Requires: nvidia-ml-py, sudo privileges
"""

import sys
import time
import argparse
from pynvml import *
import ctypes
import subprocess
import re

# ===== USER CONFIGURABLE PARAMETERS =====
CONFIG = {
    # Clock frequency limits (MHz)
    'min_clock': 210,
    'max_clock': 1740,
    
    # Temperature thresholds (¬∞C)
    'temperature_min': 20,
    'temperature_max': 80,
    
    # Power limits (watts) - for monitoring only
    'plimit_min': 20,
    'plimit_max': 120,
    
    # Frequency thresholds for offset calculation (MHz)
    'frequency_min': 900,
    'frequency_max': 1800,
    
    # Base frequency offset range (MHz)
    'freq_offset_max': 300,
    'freq_offset_min': 150,
    
    # Low frequency range settings
    'low_freq_min': 1000,
    'low_freq_max': 1440,
    'drain_offset_lmin': -30,
    'drain_offset_lmax': 0,
    
    # High frequency range settings
    'high_freq_min': 1440,
    'high_freq_max': 1800,
    'drain_offset_hmin': 0,
    'drain_offset_hmax': 15,
    
    # Critical temperature range
    'critical_temp_min': 48,
    'critical_temp_max': 61,
    
    # Power-based offset range (MHz)
    'power_offset_max': 35,
    'power_offset_min': 0,
    
    # Memory clock offset (MHz) - applied via NVML
    'memory_offset': 0,  # Set non-zero to overclock/underclock memory
    
    # Offset change threshold to prevent micro-adjustments
    'offset_change_threshold': 15,  # Only apply if offset changes by at least this much (MHz)
    
    # Performance optimizations
    'skip_idle_and_low_power_pstates': True,  # Skip offset calculations when GPU is idle or low power
    'idle_and_low_power_pstates_threshold': 1,  # P-states above this are considered idle/low-power
    'idle_status_display_interval': 10,  # Show idle status every N cycles
   
    # Control flags
    'drain_offset_control': True,
    'power_offset_control': True,
    'critical_temp_range_control': True,
    'show_info': True,
    
    # Reset clock limits on exit
    'reset_clock_limits_on_exit': False,  # Keep clock limits after script stops
    
    # Voltage monitoring legacy path (for nvidia-smi 565 or earlier)
    'nvidia_smi_legacy_path': '',  # Example: '/path/to/nvidia-smi-565'
    
    # Refresh interval (seconds)
    'refresh_interval': 1,
    
    # GPU device ID
    'gpu_id': 0,
}

def print_help():
    """Print help information about the script and configuration."""
    help_text = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                     GPU OFFSET CONTROL SCRIPT - HELP                         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

DESCRIPTION:
  This script dynamically adjusts GPU clock offsets based on temperature, power,
  and frequency using NVIDIA Management Library (NVML).

REQUIREMENTS:
  - NVIDIA GPU
  - nvidia-ml-py library (pip install nvidia-ml-py)
  - sudo privileges for applying clock limits

USAGE:
  sudo python3 gpu_offset_control.py [options]

OPTIONS:
  -h, --help     Show this help message and exit
  -d, --device   GPU device ID (default: 0)

CONFIGURABLE PARAMETERS:
  
  Clock Frequency Limits:
    min_clock              Minimum GPU clock frequency (MHz)
    max_clock              Maximum GPU clock frequency (MHz)
  
  Temperature Thresholds:
    temperature_min        Minimum temperature for offset calculations (¬∞C)
    temperature_max        Maximum temperature for offset calculations (¬∞C)
    critical_temp_min      Critical temperature range minimum (¬∞C)
    critical_temp_max      Critical temperature range maximum (¬∞C)
  
  Power Limits:
    plimit_min            Minimum power threshold (watts)
    plimit_max            Maximum power threshold (watts)
  
  Frequency Thresholds:
    frequency_min         Minimum frequency for offset calculations (MHz)
    frequency_max         Maximum frequency for offset calculations (MHz)
  
  Base Frequency Offset:
    freq_offset_max       Maximum frequency offset at frequency_min (MHz)
    freq_offset_min       Minimum frequency offset at frequency_max (MHz)
    
    ‚Üí Linearly interpolates between frequency_min and frequency_max
    ‚Üí Used for non-P0 states to prevent crashes
  
  Low Frequency Range (drain offset):
    low_freq_min          Low frequency range start (MHz)
    low_freq_max          Low frequency range end (MHz)
    drain_offset_lmin     Drain offset at temperature_min (MHz)
    drain_offset_lmax     Drain offset at temperature_max (MHz)
    
    ‚Üí Applies when GPU frequency is between low_freq_min and low_freq_max
    ‚Üí Linearly increases with temperature
    ‚Üí GPU voltage should be below 700mV
  
  High Frequency Range (drain offset):
    high_freq_min         High frequency range start (MHz)
    high_freq_max         High frequency range end (MHz)
    drain_offset_hmin     Drain offset at temperature_max (MHz)
    drain_offset_hmax     Drain offset at temperature_min (MHz)
    
    ‚Üí Applies when GPU frequency is between high_freq_min and high_freq_max
    ‚Üí Linearly decreases with temperature
    ‚Üí GPU voltage should be above 700mV
  
  Power-Based Offset:
    power_offset_max      Maximum power offset at/below plimit_min (MHz)
    power_offset_min      Minimum power offset at/above plimit_max (MHz)
    
    ‚Üí Linearly interpolates between plimit_min and plimit_max
  
  Memory Clock Offset:
    memory_offset         Memory clock offset in MHz (applied via NVML)
                          Set to non-zero to overclock memory
                          Will be reset on exit if reset_clock_limits_on_exit is True
  
  P-State Configuration:
    offset_change_threshold       Minimum offset change to trigger update (MHz)
                                  Prevents micro-adjustments that cause stuttering
    skip_idle_and_low_power_pstates  Skip calculations when GPU is idle/low-power
    idle_and_low_power_pstates_threshold  P-states above this are idle/low-power
    idle_status_display_interval  Show idle status every N cycles
  
  Control Flags:
    drain_offset_control          Enable/disable drain offset (True/False)
    power_offset_control          Enable/disable power offset (True/False)
    critical_temp_range_control   Enable/disable critical temp logic
                                  (disable drain offset in temps where voltage fluctuates) (True/False)
    show_info                     Show detailed statistics (True/False)
    reset_clock_limits_on_exit    Reset clock limits when stopping (True/False)
  
  Voltage Monitoring (nvidia-smi 565 or earlier):
    nvidia_smi_legacy_path        Path to nvidia-smi binary v565 or earlier
                                  Example: '/opt/nvidia-565/bin/nvidia-smi'
                                  Leave empty to use system nvidia-smi
  
  Refresh Settings:
    refresh_interval      Update interval in seconds

OFFSET CALCULATION:
  
  1. Base Frequency Offset (freq_offset):
     - Linearly decreases from freq_offset_max to freq_offset_min
     - Based on current GPU frequency between frequency_min and frequency_max
  
  2. Drain Offset (drain_offset):
     - Applies different offsets for low and high frequency ranges
     - Low range: Changes with temperature increase
     - High range: Changes with temperature increase
     - Critical temp range overrides if enabled to prevent crashes
  
  3. Power Offset (power_offset):
     - Maximum offset at low power consumption
     - Minimum offset at high power consumption
     - Linear transition between thresholds
  
  4. Total Offset:
     - P-state 0: Combines all enabled offsets using smart rounding
     - Other P-states: Uses freq_offset_min to prevent crashes
     - Applied to GPU using NVML

SMART ROUNDING:
  - Offsets are rounded based on offset_change_threshold
  - Only increases to next threshold if offset is >= 2/3 of the way
  - Example with threshold=15:
    * 120.0 ‚Üí 120 (8 √ó 15)
    * 129.9 ‚Üí 120 (not enough to round up)
    * 130.0 ‚Üí 135 (rounds up to 9 √ó 15)

EXAMPLES:
  
  # Run with default configuration
  sudo python3 gpu_offset_control.py
  
  # Run on GPU device 1
  sudo python3 gpu_offset_control.py -d 1
  
  # View help without applying settings
  python3 gpu_offset_control.py -h

NOTES:
  - Only P-state 0 receives calculated offsets
  - Non-P0 states use freq_offset_min to prevent crashes during periods when GPU 
    is underpowered (in menus, FMV, game emulators, etc.)
  - Script requires sudo for setting clock limits
  - Press Ctrl+C to stop the script gracefully
  - Voltage monitoring requires nvidia-smi version 565 or earlier

‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
    print(help_text)

# ===== NVML STRUCTURES =====
class c_nvmlClockOffset_t(ctypes.Structure):
    """Structure for clock offset as per NVML API."""
    _fields_ = [
        ("version", ctypes.c_uint),
        ("type", ctypes.c_uint),
        ("pstate", ctypes.c_uint),
        ("clockOffsetMHz", ctypes.c_int),
    ]

# ===== HELPER FUNCTIONS =====
def linear_interpolate(x, x_min, x_max, y_min, y_max):
    """Linear interpolation between two points."""
    if x_max == x_min:
        return y_min
    ratio = (x - x_min) / (x_max - x_min)
    ratio = max(0.0, min(1.0, ratio))  # Clamp between 0 and 1
    return y_min + ratio * (y_max - y_min)

def smart_round_offset(offset, threshold):
    """
    Round offset intelligently based on threshold.
    Only increases to next threshold multiple if offset is >= 2/3 of the way there.
    
    Example with threshold=15:
    - 120.0 -> 120 (8 * 15)
    - 129.9 -> 120 (8.66 * 15, but 0.66 < 2/3)
    - 130.0 -> 135 (8.67 * 15, and 0.67 >= 2/3)
    """
    if threshold <= 0:
        return round(offset)
    
    # How many complete threshold units
    base_units = int(offset / threshold)
    
    # Fractional part
    remainder = offset - (base_units * threshold)
    
    # If remainder is >= 2/3 of threshold, round up to next threshold
    if remainder >= (threshold * 2.0 / 3.0):
        return (base_units + 1) * threshold
    else:
        return base_units * threshold

def get_pynvml_version():
    """Get NVML version from the library."""
    try:
        version = nvmlSystemGetNVMLVersion()
        return version
    except:
        return "unknown"

def get_nvidia_smi_version():
    """Get system nvidia-smi driver version."""
    try:
        result = subprocess.run(
            ['nvidia-smi', '--query-gpu=driver_version', '--format=csv,noheader'],
            capture_output=True,
            text=True,
            timeout=2
        )
        if result.returncode == 0:
            # Parse version like "580.15.03" -> 580
            version_str = result.stdout.strip()
            match = re.match(r'(\d+)', version_str)
            if match:
                return int(match.group(1))
    except:
        pass
    return 0

def get_driver_version():
    """Get NVIDIA driver version."""
    try:
        version = nvmlSystemGetDriverVersion()
        # Extract major version number (e.g., "565.57.01" -> 565)
        match = re.match(r'(\d+)', version)
        if match:
            return int(match.group(1))
        return 0
    except:
        return 0

def get_voltage_nvidia_smi(gpu_id, nvidia_smi_path='nvidia-smi'):
    """Get GPU voltage using nvidia-smi -q -d VOLTAGE."""
    try:
        result = subprocess.run(
            [nvidia_smi_path, '-q', '-d', 'VOLTAGE', '-i', str(gpu_id)],
            capture_output=True,
            text=True,
            timeout=2
        )
        if result.returncode == 0:
            match = re.search(r'Graphics\s+:\s+([0-9.]+)\s*mV', result.stdout)
            if match:
                voltage_mv = float(match.group(1))
                return voltage_mv / 1000.0  # Convert to V
    except Exception:
        pass
    return None

def get_gpu_voltage(gpu_id, config, nvidia_smi_version):
    """
    Get GPU voltage using nvidia-smi (version 565 or earlier).
    
    Priority:
    1. System nvidia-smi (if version 565 or earlier)
    2. User-specified legacy nvidia-smi binary
    
    Returns: (voltage_value, voltage_method) or (None, None) if unavailable
    """
    
    # Priority 1: System nvidia-smi version 565 or earlier
    if nvidia_smi_version > 0 and nvidia_smi_version <= 565:
        voltage = get_voltage_nvidia_smi(gpu_id)
        if voltage is not None:
            return voltage, f"nvidia-smi {nvidia_smi_version}"
    
    # Priority 2: User-specified legacy nvidia-smi binary
    if config.get('nvidia_smi_legacy_path', ''):
        voltage = get_voltage_nvidia_smi(gpu_id, config['nvidia_smi_legacy_path'])
        if voltage is not None:
            return voltage, f"legacy nvidia-smi"
    
    return None, None

def calculate_freq_offset(freq, config):
    """Calculate base frequency offset."""
    return linear_interpolate(
        freq,
        config['frequency_min'],
        config['frequency_max'],
        config['freq_offset_max'],
        config['freq_offset_min']
    )

def calculate_drain_offset(freq, temp, config):
    """Calculate drain offset based on frequency range and temperature."""
    if not config['drain_offset_control']:
        return 0.0
    
    drain = 0.0
    
    # Critical temperature range override
    if config['critical_temp_range_control']:
        if config['critical_temp_min'] <= temp <= config['critical_temp_max']:
            if config['low_freq_min'] <= freq <= config['low_freq_max']:
                return config['drain_offset_lmin']
            elif config['high_freq_min'] <= freq <= config['high_freq_max']:
                return config['drain_offset_hmin']
    
    # Low frequency range
    if config['low_freq_min'] <= freq <= config['low_freq_max']:
        if temp >= config['temperature_max']:
            drain = config['drain_offset_lmax']
        else:
            drain = linear_interpolate(
                temp,
                config['temperature_min'],
                config['temperature_max'],
                config['drain_offset_lmin'],
                config['drain_offset_lmax']
            )
    
    # High frequency range
    elif config['high_freq_min'] <= freq <= config['high_freq_max']:
        if temp >= config['temperature_max']:
            drain = config['drain_offset_hmin']
        else:
            drain = linear_interpolate(
                temp,
                config['temperature_min'],
                config['temperature_max'],
                config['drain_offset_hmax'],
                config['drain_offset_hmin']
            )
    
    return drain

def calculate_power_offset(power, config):
    """Calculate power-based offset."""
    if not config['power_offset_control']:
        return 0.0
    
    if power <= config['plimit_min']:
        return config['power_offset_max']
    elif power >= config['plimit_max']:
        return config['power_offset_min']
    else:
        return linear_interpolate(
            power,
            config['plimit_min'],
            config['plimit_max'],
            config['power_offset_max'],
            config['power_offset_min']
        )

def get_gpu_stats(handle, gpu_id, config, nvidia_smi_version):
    """Retrieve current GPU statistics."""
    try:
        temp = nvmlDeviceGetTemperature(handle, NVML_TEMPERATURE_GPU)
        power = nvmlDeviceGetPowerUsage(handle) / 1000.0  # Convert to watts
        clock = nvmlDeviceGetClockInfo(handle, NVML_CLOCK_GRAPHICS)
        
        # Get current P-state
        try:
            pstate = nvmlDeviceGetPerformanceState(handle)
        except:
            pstate = 0  # Assume P0 if unable to get P-state
        
        # Try to get voltage
        voltage_value, voltage_method = get_gpu_voltage(gpu_id, config, nvidia_smi_version)
        
        return {
            'temperature': temp,
            'power': power,
            'frequency': clock,
            'pstate': pstate,
            'voltage_value': voltage_value,
            'voltage_method': voltage_method
        }
    except NVMLError as e:
        print(f"Error getting GPU stats: {e}", file=sys.stderr)
        return None

def apply_clock_limits(handle, config):
    """Apply GPU clock frequency limits (requires sudo)."""
    try:
        nvmlDeviceSetGpuLockedClocks(
            handle,
            config['min_clock'],
            config['max_clock']
        )
        print(f"‚úì Clock limits set: {config['min_clock']}-{config['max_clock']} MHz")
        return True
    except NVMLError as e:
        print(f"‚úó Error setting clock limits: {e}")
        print("  Note: This operation requires sudo privileges")
        return False

def set_pstate_clock_offset(handle, clock_type, clock_offset, pstate):
    """Set clock offset for a specific P-state."""
    try:
        struct = c_nvmlClockOffset_t()
        struct.version = nvmlClockOffset_v1
        struct.type = clock_type
        struct.pstate = pstate
        struct.clockOffsetMHz = clock_offset
        nvmlDeviceSetClockOffsets(handle, ctypes.byref(struct))
    except NVMLError:
        pass  # Silently ignore errors

def apply_clock_offset(handle, offset, pstate=0):
    """Apply GPU clock offset using NVML."""
    try:
        offset_value = int(offset)
        # Apply offset to specified P-state
        # NVML_CLOCK_GRAPHICS = 0 for graphics clock
        set_pstate_clock_offset(handle, 0, offset_value, pstate)
        return True
    except Exception:
        return False

def apply_memory_offset(handle, offset, pstate=0):
    """Apply memory clock offset using NVML."""
    try:
        offset_value = int(offset)
        # Apply memory offset to specified P-state
        # NVML_CLOCK_MEM = 2 for memory clock
        set_pstate_clock_offset(handle, 2, offset_value, pstate)
        return True
    except Exception:
        return False

def display_stats(stats, offsets, total_offset_raw, total_offset, config, status="ACTIVE"):
    """Display current GPU statistics and offset information."""
    if not config['show_info']:
        return
    
    print("\n" + "="*80)
    print(f"GPU Statistics: [{status}] - {time.strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*80)
    print(f"  P-State:       P{stats['pstate']}")
    print(f"  Frequency:     {stats['frequency']:>6} MHz")
    print(f"  Temperature:   {stats['temperature']:>6}¬∞C")
    print(f"  Power:         {stats['power']:>6.1f} W")
    
    # Show voltage if available
    if stats['voltage_value'] is not None:
        print(f"  Voltage:       {stats['voltage_value']:>6.3f} V")
    
    if stats['pstate'] == 0:
        print(f"\nOffset Breakdown:")
        print(f"  Freq Offset:   {offsets['freq']:>6.1f} MHz")
        
        if config['drain_offset_control']:
            print(f"  Drain Offset:  {offsets['drain']:>6.1f} MHz")
        else:
            print(f"  Drain Offset:  DISABLED")
        
        if config['power_offset_control']:
            print(f"  Power Offset:  {offsets['power']:>6.1f} MHz")
        else:
            print(f"  Power Offset:  DISABLED")
        
        print(f"\n  Raw Total:     {total_offset_raw:>6.1f} MHz")
        print(f"  Applied:       {total_offset:>6} MHz")
    else:
        print(f"\nOffset: Using freq_offset_min ({config['freq_offset_min']} MHz) for non-P0 state")
    
    print("="*80)

def main():
    """Main control loop."""
    parser = argparse.ArgumentParser(
        description='GPU Offset Control using NVML',
        add_help=False
    )
    parser.add_argument('-h', '--help', action='store_true', help='Show help message')
    parser.add_argument('-d', '--device', type=int, default=CONFIG['gpu_id'], help='GPU device ID')
    
    args = parser.parse_args()
    
    if args.help:
        print_help()
        return
    
    # Initialize NVML
    try:
        nvmlInit()
    except NVMLError as e:
        print(f"Failed to initialize NVML: {e}")
        sys.exit(1)
    
    try:
        # Get GPU handle
        handle = nvmlDeviceGetHandleByIndex(args.device)
        gpu_name = nvmlDeviceGetName(handle)
        driver_version = get_driver_version()
        pynvml_version = get_pynvml_version()
        nvidia_smi_version = get_nvidia_smi_version()
        
        print(f"\nüéÆ GPU Device: {gpu_name} (ID: {args.device})")
        print(f"üì¶ Driver Version: {driver_version}")
        print(f"üì¶ NVML Version: {pynvml_version}")
        print(f"üì¶ nvidia-smi Driver: {nvidia_smi_version}")
        
        # Check voltage monitoring capability
        if nvidia_smi_version > 0 and nvidia_smi_version <= 565:
            print("‚úì Voltage monitoring: Available (system nvidia-smi)")
        elif CONFIG.get('nvidia_smi_legacy_path', ''):
            print(f"‚ö†Ô∏è  Voltage monitoring: Using legacy nvidia-smi")
            print(f"  ‚Üí Path: {CONFIG['nvidia_smi_legacy_path']}")
            # Test legacy binary
            try:
                test_result = subprocess.run(
                    [CONFIG['nvidia_smi_legacy_path'], '--version'],
                    capture_output=True,
                    text=True,
                    timeout=2
                )
                if test_result.returncode == 0:
                    print(f"  ‚Üí Test: OK")
                else:
                    print(f"  ‚Üí Test: FAILED (return code {test_result.returncode})")
            except Exception as e:
                print(f"  ‚Üí Test: ERROR - {e}")
        else:
            print("‚ö†Ô∏è  Voltage monitoring: Not available (nvidia-smi > 565)")
            print("  ‚Üí Configure 'nvidia_smi_legacy_path' if needed")
        
        # Apply clock limits once
        print("\nüìä Applying initial settings...")
        if not apply_clock_limits(handle, CONFIG):
            print("‚ö†Ô∏è  Warning: Failed to set clock limits. Continuing anyway...")
        
        # Apply memory offset if configured
        if CONFIG['memory_offset'] != 0:
            if apply_memory_offset(handle, CONFIG['memory_offset'], 0):
                print(f"‚úì Memory offset applied: {CONFIG['memory_offset']} MHz")
            else:
                print(f"‚úó Failed to apply memory offset: {CONFIG['memory_offset']} MHz")
        
        print(f"\nüîÑ Starting offset control loop (refresh: {CONFIG['refresh_interval']}s)")
        print("Press Ctrl+C to stop\n")
        
        # Track last applied offset
        last_applied_offset = None
        
        # Performance tracking
        idle_count = 0
        
        # Main control loop
        while True:
            loop_start = time.time()
            
            # Get current GPU stats
            stats = get_gpu_stats(handle, args.device, CONFIG, nvidia_smi_version)
            if not stats:
                time.sleep(CONFIG['refresh_interval'])
                continue
            
            # Check if GPU is in idle/low-power P-state
            is_idle_or_low_power = CONFIG['skip_idle_and_low_power_pstates'] and \
                                   stats['pstate'] > CONFIG['idle_and_low_power_pstates_threshold']
            
            if is_idle_or_low_power:
                idle_count += 1
                # Display status periodically when idle
                if CONFIG['show_info'] and idle_count % CONFIG['idle_status_display_interval'] == 0:
                    print(f"\n{'='*80}")
                    print(f"GPU Status: [IDLE/LOW-POWER - P{stats['pstate']}]")
                    print(f"  Frequency:     {stats['frequency']:>6} MHz")
                    print(f"  Temperature:   {stats['temperature']:>6}¬∞C")
                    print(f"  Power:         {stats['power']:>6.1f} W")
                    print(f"  Idle cycles:   {idle_count}")
                    print(f"{'='*80}")
                
                time.sleep(CONFIG['refresh_interval'])
                continue
            
            # Reset idle counter when active
            if idle_count > 0 and CONFIG['show_info']:
                print(f"\n‚ö° GPU became active after {idle_count} idle cycles")
                idle_count = 0
            
            # Determine which offset to apply based on P-state
            if stats['pstate'] == 0:
                # P0 state - calculate full offset
                freq_offset = calculate_freq_offset(stats['frequency'], CONFIG)
                drain_offset = calculate_drain_offset(stats['frequency'], stats['temperature'], CONFIG)
                power_offset = calculate_power_offset(stats['power'], CONFIG)
                
                # Calculate total offset
                total_offset_raw = freq_offset
                if CONFIG['drain_offset_control']:
                    total_offset_raw += drain_offset
                if CONFIG['power_offset_control']:
                    total_offset_raw += power_offset
                
                # Apply smart rounding for P0 state
                total_offset = smart_round_offset(total_offset_raw, CONFIG['offset_change_threshold'])
            else:
                # Non-P0 state - use freq_offset_min rounded to valid GPU firmware step
                freq_offset = CONFIG['freq_offset_min']
                drain_offset = 0
                power_offset = 0
                total_offset_raw = CONFIG['freq_offset_min']
                # Round freq_offset_min to nearest valid step (divisible by offset_change_threshold)
                total_offset = round(CONFIG['freq_offset_min'] / CONFIG['offset_change_threshold']) * CONFIG['offset_change_threshold']
            
            # Only apply offset if it has changed
            should_apply = (last_applied_offset is None) or (total_offset != last_applied_offset)
            
            if should_apply:
                if apply_clock_offset(handle, total_offset, 0):
                    last_applied_offset = total_offset
            
            # Display statistics
            display_stats(stats, {
                'freq': freq_offset,
                'drain': drain_offset,
                'power': power_offset
            }, total_offset_raw, total_offset, CONFIG, "ACTIVE")
            
            # Calculate sleep time to maintain consistent refresh rate
            loop_duration = time.time() - loop_start
            sleep_time = max(0, CONFIG['refresh_interval'] - loop_duration)
            time.sleep(sleep_time)
    
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Stopping GPU offset control...")
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        # Cleanup
        try:
            if CONFIG['reset_clock_limits_on_exit']:
                # Reset everything to default
                nvmlDeviceResetGpuLockedClocks(handle)
                print("‚úì Clock limits reset")
                
                # Reset graphics clock offset to 0
                apply_clock_offset(handle, 0, 0)
                print("‚úì Graphics clock offset reset to 0")
                
                # Reset memory offset to 0 if it was applied
                if CONFIG['memory_offset'] != 0:
                    apply_memory_offset(handle, 0, 0)
                    print("‚úì Memory clock offset reset to 0")
            else:
                # Keep clock limits but apply stable freq_offset_min
                # Round to valid firmware step
                stable_offset = round(CONFIG['freq_offset_min'] / CONFIG['offset_change_threshold']) * CONFIG['offset_change_threshold']
                apply_clock_offset(handle, stable_offset, 0)
                print(f"‚úì Keeping clock limits with stable offset: {stable_offset} MHz")
                print("‚úì Memory offset kept as configured")
        except Exception as e:
            print(f"‚ö†Ô∏è  Cleanup warning: {e}")
        
        nvmlShutdown()
        print("‚úì NVML shutdown complete\n")

if __name__ == "__main__":
    main()
